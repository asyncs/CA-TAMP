start with list old
//        auto* postOpNode = new rai::LGP_Node(*this, rai::BD_max);
//
//        copyNode(postOpNode, node);
//
//        if (!node->children){
//            postOpNode->children = nullptr;
//        }
//        else{
//            if (fringe_expand.N != 0){
//                postOpNode->children = fringe_expand.first();
//            }
//        }
//
//        if (!node->parent){
//            postOpNode->parent = nullptr;
//        }
//        else{
//            if (fringe_expand.N != 0){
//                fringe_expand.first()->parent = postOpNode;
//            }
//        }
//        fringe_expand.prepend(postOpNode);
//        if (postOpNode->decision){
//            cout << "Decision: " << *postOpNode->decision << endl;
//        }
//        else{
//            cout << "Decision: ROOT " << endl;
//        }
//        if(postOpNode->count(1)) fringe_pose.prepend(postOpNode);
//        cout << "Remaining Node: " << node->getTreePathString() <<endl;
//        cout << "New fringe: " << fringe_expand.last()->getTreePathString() <<endl;
//        node = node->parent;
//    }



//void MiniLGP::copyNode(rai::LGP_Node *newNode, rai::LGP_Node *existingNode) {
//    newNode->skeleton = existingNode->skeleton;
//    newNode->problem = existingNode->problem;
//    newNode->step = existingNode->step;
//    newNode->time = existingNode->time;
//    newNode->decision = existingNode->decision;
//    newNode->ret = existingNode->ret;
//    newNode->isExpanded = existingNode->isExpanded;
//    newNode->isInfeasible = existingNode->isInfeasible;
//    newNode->isTerminal = false;
//    newNode->L = existingNode->L;
//    newNode->cost = existingNode->cost;
//    newNode->constraints = existingNode->constraints;
//    newNode->feasible = existingNode->feasible;
//    newNode->count = existingNode->count;
//    newNode->computeTime = existingNode->computeTime;
//    newNode->highestBound = existingNode->highestBound;
//    newNode->note = existingNode->note;
//}